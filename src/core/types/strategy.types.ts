/**
 * Strategy types for trading strategy framework
 * Defines interfaces for backtesting, paper trading, and live trading
 */

import type { Candle, Timeframe } from './market.types';
import type { Portfolio, Order, Trade, OrderSide } from './trading.types';

/**
 * Trading mode
 */
export type TradingMode = 'backtest' | 'paper' | 'live';

/**
 * Strategy configuration
 */
export interface StrategyConfig {
  /** Trading mode */
  mode: TradingMode;
  /** Symbols to trade */
  symbols: string[];
  /** Primary timeframe for the strategy */
  timeframe: Timeframe;
  /** Initial capital */
  initialCapital: number;
  /** Commission rate (e.g., 0.001 = 0.1%) */
  commission: number;
  /** Slippage estimate (e.g., 0.001 = 0.1%) */
  slippage: number;
  /** Risk per trade (e.g., 0.02 = 2% of capital) */
  riskPerTrade: number;
  /** Maximum concurrent positions */
  maxPositions: number;
  /** Strategy-specific parameters */
  parameters?: Record<string, unknown>;
}

/**
 * Strategy execution context
 * Contains all data available to the strategy during execution
 */
export interface StrategyContext {
  /** Historical candles per symbol */
  candles: Map<string, Candle[]>;
  /** Calculated indicators per symbol */
  indicators: Map<string, Record<string, unknown>>;
  /** Current portfolio state */
  portfolio: Portfolio;
  /** Current timestamp (for backtesting) */
  currentTime: number;
  /** Trading mode */
  mode: TradingMode;
  /** Additional context data */
  metadata?: Record<string, unknown>;
}

/**
 * Trading signal generated by strategy
 */
export interface Signal {
  /** Signal type */
  type: 'entry' | 'exit';
  /** Buy or sell */
  side: OrderSide;
  /** Trading symbol */
  symbol: string;
  /** Signal strength/confidence (0-1) */
  strength: number;
  /** Suggested entry price (optional) */
  price?: number;
  /** Suggested stop loss (optional) */
  stopLoss?: number;
  /** Suggested take profit (optional) */
  takeProfit?: number;
  /** Signal generation timestamp */
  timestamp: number;
  /** Reason for the signal (optional) */
  reason?: string;
  /** Additional metadata */
  metadata?: Record<string, unknown>;
}

/**
 * Strategy performance metrics
 */
export interface StrategyMetrics {
  /** Total return (%) */
  totalReturn: number;
  /** Annual return (%) */
  annualReturn: number;
  /** Sharpe ratio */
  sharpeRatio: number;
  /** Sortino ratio */
  sortinoRatio: number;
  /** Maximum drawdown (%) */
  maxDrawdown: number;
  /** Win rate (%) */
  winRate: number;
  /** Average win (%) */
  averageWin: number;
  /** Average loss (%) */
  averageLoss: number;
  /** Profit factor */
  profitFactor: number;
  /** Total number of trades */
  totalTrades: number;
  /** Winning trades */
  winningTrades: number;
  /** Losing trades */
  losingTrades: number;
  /** Average trade duration (ms) */
  averageTradeDuration: number;
  /** Additional metrics */
  [key: string]: number;
}

/**
 * Base strategy interface
 * All trading strategies must implement this interface
 *
 * @example
 * ```typescript
 * export class SMACrossoverStrategy implements IStrategy {
 *   readonly name = 'SMA Crossover';
 *   readonly description = 'Simple moving average crossover strategy';
 *
 *   constructor(public config: StrategyConfig) {}
 *
 *   async initialize(context: StrategyContext) {
 *     // Setup indicators, load data, etc.
 *   }
 *
 *   async onCandle(candle: Candle, context: StrategyContext): Promise<Signal[]> {
 *     // Generate trading signals based on candle data
 *     return signals;
 *   }
 *
 *   getParameters() {
 *     return { fastPeriod: 20, slowPeriod: 50 };
 *   }
 *
 *   setParameters(params: Record<string, unknown>) {
 *     // Update strategy parameters
 *   }
 * }
 * ```
 */
export interface IStrategy {
  /** Strategy name */
  readonly name: string;
  /** Strategy description */
  readonly description: string;
  /** Strategy configuration */
  readonly config: StrategyConfig;

  /**
   * Initialize the strategy
   * Called once before strategy execution starts
   * @param context - Strategy execution context
   */
  initialize(context: StrategyContext): Promise<void>;

  /**
   * Process a new candle and generate signals
   * Called for each new candle in the data stream
   * @param candle - New candle data
   * @param context - Current strategy context
   * @returns Array of trading signals (can be empty)
   */
  onCandle(candle: Candle, context: StrategyContext): Promise<Signal[]>;

  /**
   * Called when a trade is executed (optional)
   * Allows strategy to react to trade fills
   * @param trade - Executed trade
   * @param context - Current strategy context
   */
  onTrade?(trade: Trade, context: StrategyContext): Promise<void>;

  /**
   * Called when an order is filled (optional)
   * @param order - Filled order
   * @param context - Current strategy context
   */
  onOrderFilled?(order: Order, context: StrategyContext): Promise<void>;

  /**
   * Called when an order is cancelled (optional)
   * @param order - Cancelled order
   * @param context - Current strategy context
   */
  onOrderCancelled?(order: Order, context: StrategyContext): Promise<void>;

  /**
   * Cleanup and release resources (optional)
   * Called when strategy execution ends
   */
  cleanup?(): Promise<void>;

  /**
   * Get strategy parameters
   * @returns Current parameter values
   */
  getParameters(): Record<string, unknown>;

  /**
   * Update strategy parameters
   * @param params - New parameter values
   */
  setParameters(params: Record<string, unknown>): void;
}

/**
 * Backtest result
 */
export interface BacktestResult {
  /** Strategy name */
  strategy: string;
  /** Trading symbols */
  symbols: string[];
  /** Backtest start time */
  startTime: number;
  /** Backtest end time */
  endTime: number;
  /** Initial capital */
  initialCapital: number;
  /** Final capital */
  finalCapital: number;
  /** Performance metrics */
  metrics: StrategyMetrics;
  /** All trades executed */
  trades: Trade[];
  /** Equity curve (timestamp, equity pairs) */
  equityCurve: [number, number][];
  /** Drawdown curve (timestamp, drawdown% pairs) */
  drawdownCurve: [number, number][];
}

/**
 * Strategy state for persistence
 */
export interface StrategyState {
  /** Strategy name */
  strategy: string;
  /** Current positions */
  positions: Map<string, unknown>;
  /** Indicator values */
  indicators: Map<string, unknown>;
  /** Last processed timestamp */
  lastTimestamp: number;
  /** Custom state data */
  data: Record<string, unknown>;
}
